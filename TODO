* parse.pl/p2.pl: factor out parsing code into module. Cleanup.
* codewords.asm: logic to check if pushA/pushDA has already been defined is broken
* compile.sh: ugly hack, layers upon layers of "just another small script"
* asmlib: outdated version, but newlib also needs major rework
* tests. half of the obscure options are broken at any moment
* really small inner interpreter (just lodsw/jmp) missing/hidden in another branch
* did variables ever exist?
* forth-to-bytecode via nasm is a mess: compile-time constants in nasm, other
  constants in the forth part, stuff I don't remember right now...
  lit8/lit32 tracking
* forth compiler: simplify stuff like "1 1 +" and "3 not"
* ":?" words: inside should not be checked for reachability if it isn't clear that they are needed
  (e.g. syscall3 defined as :?-word, syscall7 now required. but should not be required if syscall7
  never used elswehere)
* options that are probably broken: PIC, SMALLINIT, whole 64bit stuff
* rsdrop not accesible if EXIT not used
* parse.pl also has TODO section, check what is still valid...
* words like ": foo bar ;" should be interpreted as an alias even if INLINE==0
* Move 'rwx' function to Forth: mprotect only takes 3 arguments.
* Move biggest codeword to end (seems to be syscall3). Move as much pushA/clearA code there.
  Use *start* of word as the break. This makes using 8bit cmp a bit easier to use.
* eax does not get cleared anymore if SCALED==0. But lit8 *still* needs it to be clear.
* Documentation: stack is NOT aligned, esp. with SMALLINIT==3
* Some options interpret empty as false, others as 'use default'. E.g. "FULL=" vs "INLINE="
* always inline some words, e.g. ones doing return stack stuff
* r@/i Forth words do not work in MAIN
* findauto includes asm way to aggresively. Needs to be pruned/minimized first and then check
* xchg instead of mov in DOCOL -> sideeffects?
* INLINEALL keyword to inline everything into a word for speed reasons
* clear distinction/table which word we want asm and which in Forth
* p2.pl really is a mess with pruning/inlining/etc running multiple times for no apparent reason
* WORD macro in macros.asm: what is still needed, what can be refactored/deleted?
* SCALED==0: use base+offset? can we use 16b offsets?
* parser: detect if word != MAIN at the end. Detect if we "end" main with a ;
* a mode for WORD_ALIGN==1 without using ecx, but directly eax
* would keeping top-of-stack in a register decrease overall code size? Every indirect access,
  e.g. inc native [SP] is +1 bytes
* p2.pl: Inline/length calculations: branch offsets in if/unless etc. get ignored (also, BRANCH8/32)



Major parts:

* asmlib/: low-level asm stuff, ELF file creation, low-level debug functions
* parse.pl: parse forth file, create bytecode/nasm file that can be included by main asm structure
* p2.pl: optimizer/inliner/pruning
* viert.sh: low-level forth compiler. nasm and parse.pl
* optim.sh: optimizing compiler. concatenate library to forth file, run p2.pl, run ./f2
* f2: optimized forth generated by p2.pl. Also a shell script that runs viert.sh to compile
* compiled.asm: pseudoassembler/bytecode file generated by parse.pl
* viert3.asm: main assembler file, pulls in all other assembly stuff
* codewords.asm: forth words defined in assembler
* macros.asm: various macros
* wordset.asm: generated by p2.pl. Assembler words used.


